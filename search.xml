<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[js是按值传递还是按引用传递]]></title>
      <url>%2F2017%2F03%2F30%2Fjs%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
      <content type="text"><![CDATA[变量在内存中的存储方式要弄清楚这个问题，首先要知道变量在内存中的存储方式，js中的数据类型分为两类： 基本类型：包括 Number、String、Boolean、Undefined、Null 引用类型：包括 Object、Array、Date、Function 等 对于这两种数据类型，有不同的内存分配，我们声明如下两个变量12var a = 100;var b = &#123; age: 30 &#125;; 通过下面这张图就可以看清楚变量 a 和 b 在内存中的存储方式 基本类型：存储在栈（stack）中的简单数据段，他们的值直接存储在变量访问的位置。这是因为基本类型占据的空间是固定的，可以存储在较小的内存区域栈中，以便于快速查找变量的值 引用类型：存储在堆（heap）中的对象，这个时候，存储在变量处值其实是一个指针（point），指向该对象在内存中的地址。这是因为引用值是可变的（可以动态增加新的属性），所以不能存储在栈中，否则会降低变量的查找速度。 复制变量时的不同现在我们增加两个变量 c 和 d1234var a = 100;var b = &#123; age: 30 &#125;;var c = a;var d = b; 这个时候变量 c、d 在内存中的存储方式变成了这样 此时我们改变 c、d 的值，看一下 a、b 是否也会被改变123456c = 200;d.sex = '男';console.log(c); // 200console.log(a); // 100console.log(d); // &#123; age: 30, sex: '男' &#125;console.log(b); // &#123; age: 30, sex: '男' &#125; 上面代码中我们是给 d 新增了一个 sex 属性，如果是重新给 d 赋值，结果又会怎么样呢？123d = &#123; name: 'gwyi' &#125;;console.log(d); // &#123; name: 'gwyi' &#125;console.log(b); // &#123; age: 30, sex: '男' &#125; 为什么会出现这样的结果呢？给 d 重新赋值之后，并没有改变 b 的值，这是因为给 d 重新赋值之后，d 就指向了堆内存中的 { name: ‘gwyi’ }，而不再指向 { age: 30 } 基本类型：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，这两个变量是相互独立的，更改其中一个的值不会影响到另一个 引用类型：在将一个保存着对象内存地址的变量赋值给另一个变量时，会把这个内存地址赋值给新的变量（并不会在堆内存中新生成一个一模一样的对象），此时这两个变量都指向了堆内存中的同一个对象，对其中任何一个属性值的修改都会同步反映在另一个身上 什么是按值传递？按引用传递？看下面的 c++ 中的例子来解释什么是值传递和引用传递1234567891011121314151617//值传递void change1(int n)&#123; n++;&#125;//引用传递void change2(int &amp; n)&#123; n++;&#125;int main() &#123; int a = 10; change1(a); cout&lt;&lt;'a='&lt;&lt;a&lt;&lt;endl; // a=10 change2(a); cout&lt;&lt;'a='&lt;&lt;a&lt;&lt;endl; // a=11&#125; 值传递：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。change1使用的是值传递，当修改形参 n 的值时，实参 a 的值并没有被改变 引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。change2使用的是引用传递，当修改形参 n 的值时，实参 a 的值也会被改变 js中参数的传递方式js中的基本类型是按值传递的123456function change(n) &#123; n++;&#125;var a = 10;change(a);console.log(a); // 10 不受 n++ 的影响 再来看引用类型123456function change(obj) &#123; obj.name = 'gwyi';&#125;var a = &#123; age: 30 &#125;;change(a);console.log(a); // &#123; age: 30, name: 'gwyi' &#125; a 的值被修改了 a 的值被修改了，说明不是按值传递，那就是按引用传递吗？再来看这个例子123456function change(obj) &#123; obj = &#123; name: 'gwyi' &#125;;&#125;var a = &#123; age: 30 &#125;;change(a);console.log(a); // &#123; age: 30 &#125; a 的值没有被修改 如果是按引用传递，当修改形参 obj 的值时，a 的值应该也会被修改，但实际情况是 a 的值并没有被修改，说明并不是按引用传递，那js中引用类型的值究竟是按什么方式传递的呢？ 按共享传递准确的说，js中的基本类型是按值传递，引用类型是按共享传递（call by sharing），最早由 Barbara Liskov 提出，该求值策略被用于 Python、Java、Ruby、JavaScript 等多种语音 该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对形参的重新赋值，不会影响实参的值。这就是上面这个例子中 a 的值没有被修改的原因123456function change(obj) &#123; obj = &#123; name: 'gwyi' &#125;;&#125;var a = &#123; age: 30 &#125;;change(a);console.log(a); // &#123; age: 30 &#125; a 的值没有被修改 其实这就和上面“复制变量时的不同”（上面图三所示）写到的一样，开始的时候 a 和 obj 都指向堆内存中的 { age: 30 }，当为 obj 重新赋值时，obj 就不在指向 { age: 30 } 这个对象，而是指向 { name: ‘gwyi’ } 这个新的对象 而对于下面这种 a 的值被修改了的情况，就和上面图二所示的一样， a 和 obj 都指向堆内存中的 { age: 30 }，此时 obj 新增的属性值也会同步影响 a 的值1234567function change(obj) &#123; obj.name = 'gwyi'; console.log(obj); // &#123; age: 30, name: 'gwyi' &#125;&#125;var a = &#123; age: 30 &#125;;change(a);console.log(a); // &#123; age: 30, name: 'gwyi' &#125; a 的值被修改了 以上内容也是自己在看了其他同学的解答之后整理出来的，并非自己原创！ 参考链接知乎：“苏墨橘”回答javascript传递参数如果是object的话，是按值传递还是按引用传递？JS是按值传递还是按引用传递?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js判断数据类型]]></title>
      <url>%2F2017%2F03%2F29%2Fjs%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[js中的数据类型js中的数据类型大致可以分为以下几种： 基本类型：number、 string、 boolean 特殊类型：undefined、 null 引用类型：Object、 Function、 Date、 Array 等等 下面介绍js中提供的三种判断数据类型的方法 typeoftypeof 返回一个表示数据类型的字符串，返回值有 number、 string、 boolean、 undefined、 object、 function 这6种12345678910typeof 123; // numbertypeof ''; // stringtypeof true; // booleantypeof undefined; // undefinedtypeof null; // object 不能正确判断出null类型typeof new Function(); // functiontypeof &#123;&#125;; // objecttypeof []; // object 不能正确判断出数组类型typeof new Date(); // object 不能正确判断出日期类型typeof new RegExp(); // object 不能正确判断出正则类型 从上面的结果中可以看出 typeof 可以正确判断出基本类型，但是对于 null、Date、Array 等都是返回 object，不能得到具体的类型，使用的时候需要特别注意 instanceofinstanceof检测的是原型，可以判断 a 是否为 b 的实例， 使用方式为：a instanceof b，其内部执行过程如下123function instanceof(a, b) &#123; return a.__proto__ === b.prototype;&#125; 如果 a 的 __proto__ 指向 b 的 prototype 时，就认为 a 是 b 的实例12345678910[] instanceof Array; // truenew Date() instanceof Date; // truenew RegExp() instanceof RegExp; // truefunction Car() &#123;&#125;;new Car() instanceof Car; // true[] instanceof Object; // truenew Date() instanceof Object; // truenew RegExp() instanceof Object; // truenew Car() instanceof Object; // true 从上面的代码可以看出，instanceof 能够判断出 [] 是 Array 的实例，但也认为 [] 是 Object 的实例，这是为什么呢？看下面的代码就明白了123[].__proto__ === Array.prototype; // trueArray.prototype.__proto__ === Object.prototype; // trueObject.prototype.__proto__ === null; // true 从 [] -&gt; Array -&gt; Object -&gt; null 这四者构成了一条原型链，[] 的 __proto__ 直接指向 Array.prototype，间接指向 Object.prototype，所以 [] 也是 Object 的实例，类似new Date()、new Car() 也会形成一条这样的原型链，因此，instanceof 只能用来判断两个对象是否属于原型链的关系，而不能获得对象的具体类型 Object.prototype.toString可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测（这是因为大部分对象都实现了自身的 toString 方法，如果通过 [1, 2].toString() 这种方式来调用的话，是无法获取到具体类型的），需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，把需要检测的对象作为第一个参数传入1234567891011Object.prototype.toString.call(123); // [object Number]Object.prototype.toString.call('abc'); // [object String]Object.prototype.toString.call(true); // [object Boolean]Object.prototype.toString.call(undefined); // [object Undefined]Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call(&#123;&#125;); // [object Object]Object.prototype.toString.call([]); // [object Array]Object.prototype.toString.call(function()&#123;&#125;); // [object Function]Object.prototype.toString.call(new Date()); // [object Date]Object.prototype.toString.call(new RegExp()); // [object RegExp]Object.prototype.toString.call(new Error()); // [object Error] 通过上面的代码可以看出 Object.prototype.toString 基本能够准确的获取到所有对象的具体类型，事实上 jQuery 中的 type() 方法也是通过这种方式来实现的 jQuery 中 type() 方法实现源码jQuery 中 type 方法实现源码，123456789101112131415161718192021222324252627282930313233// 用于预存储一张类型表用于 hookvar class2type = &#123;&#125;;// 原生的 typeof 方法并不能区分出一个变量它是 Array 、RegExp 等 object 类型，jQuery 为了扩展 typeof 的表达力，因此有了 $.type 方法// 针对一些特殊的对象（例如 null，Array，RegExp）也进行精准的类型判断// 运用了钩子机制，判断类型前，将常见类型打表，先存于一个 Hash 表 class2type 里边"Boolean Number String Function Array Date RegExp Object Error".split(" ").forEach(function(name, i) &#123; class2type["[object " + name + "]"] = name.toLowerCase();&#125;);// 确定JavaScript 对象的类型function type(obj) &#123; if (obj == null) &#123; return String(obj); &#125; // 利用事先存好的 hash 表 class2type 作精准判断 // 这里因为 hook 的存在，省去了大量的 else if 判断 return typeof obj === "object" || typeof obj === "function" ? class2type[Object.prototype.toString.call(obj)] || "object" : typeof obj;&#125;// exampletype(123); // numbertype('abc'); // stringtype(true); // booleantype(undefined); // undefinedtype(null); // nulltype([]); // arraytype(&#123;&#125;); // objecttype(function()&#123;&#125;); // functiontype(new Date()); // datetype(new RegExp()); // regexp 参考链接JS 判断数据类型的三种方法javascript判断数据类型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS安装及启动mongodb]]></title>
      <url>%2F2017%2F03%2F08%2FmacOS%E5%AE%89%E8%A3%85%E5%8F%8A%E5%90%AF%E5%8A%A8mongodb%2F</url>
      <content type="text"><![CDATA[我今天介绍的是使用homebrew安装mongodb，homebrew是mac上的套件管理器，可以帮助我们方便的安装、删除、更新应用程序，mongodb是一种noSQL数据库，及非关系型数据库（不同于传统的关系型数据库MySQL、orcal等），现在也越来越流行，很多大公司比如Google和Facebook等都在使用 homebrew在安装mongodb之前让我们先简单了解一下homebrew的使用方式，首先安装homebrew，只需要在命令行执行下面的命令即可1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装成功之后可以输入brew -h查看brew的使用方式，下面列出几个常用的命令 命令 说明 brew update 更新homebrew的版本 brew list 显示使用brew安装的软件列表 brew outdated 查看哪些软件需要更新 brew upgrade [软件名称] 更新某个使用brew安装的软件（如果不写软件名称，就更新所有的软件） brew install 软件名称 安装软件 brew uninstall 软件名称 卸载软件 brew安装mongodb安装mongodb只需要执行下面的命令1npm install mongodb 安装成功之后可以在控制台看到如下信息 提示信息告诉我们可以使用两种方式启动mongodb，分别是使用brew services start mongodb和mongod --config /usr/local/etc/mongod.conf注意：在启动mongodb之前，我们需要创建一个目录，作为为mongodb默认的数据写入目录1sudo mkdir -p /data/db 然后给刚刚创建的目录以可读可写的权限1sudo chown `id -u` /data/db 最后执行下面的命令就可以启动mongodb了1mongod --config /usr/local/etc/mongod.conf 我们可以新开一个终端窗口连接数据库并试着查看所有的数据库：1mongo 会看到如下信息 输入show dbs可以查看所有的数据库，输入db可以显示当前连接的数据库，使用use 数据库名可以切换数据库 参考链接Mac下使用brew安装mongodbMAC OSX 安装MongoDB]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习笔记（四）：for...of循环]]></title>
      <url>%2F2017%2F02%2F19%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Afor-of%E5%BE%AA%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[ES6引入了for...of循环，作为遍历所有数据结构的统一方式。只要一个数据结构部署了Symbol.iterator属性，就被视为拥有Iterator接口，就可以用for...of遍历。for...of循环可以遍历数组、Set和Map结构、类似数组的对象、Generator对象以及字符串。注意，for…of不能遍历对象，因为对象没有iterator接口，对象可以使用for…in遍历。 遍历数组数组原生就具有Iterator接口，可以直接使用for…of遍历。1234let arr = ['apple', 'orange', 'pear'];for(let value of arr) &#123; console.log(value); // apple orange pear&#125; 上面代码的遍历方式只能获得数组的值，不能获得索引，如果要遍历索引可以使用数组的entries或者keys方法。1234567let arr = ['apple', 'orange', 'pear'];for(let [key, value] of arr.entries()) &#123; console.log(key, value); // 0 "apple" // 1 "orange" // 2 "pear"&#125; 遍历Set和Map结构在前面的“Set和Map数据结构”已经详细讲过使用for...of遍历Set和Map结构了，用法也很简单。123456789101112let set = new Set(['apple', 'orange', 'pear']);for(let value of set) &#123; console.log(value); // apple orange pear&#125;let map = new Map([['apple', 'like'], ['orange', 'dislike'], ['pear', 'like']]);for(let item of map) &#123; console.log(item); // ["apple", "like"] // ["orange", "dislike"] // ["pear", "like"]&#125; 上面代码中分别演示了for...of遍历Set和Map结构，需要注意的一点是Set结构默认是调用values方法，返回键值的遍历器。而Map结构默认是调用entries方法，返回键值对的遍历器。 遍历类似数组的对象类似数组的对象有很多种，下面是使用for...of遍历字符串、arguments对象以及DOM NodeList对象。12345678910111213141516171819// 字符串let str = 'hello';for(let value of str) &#123; console.log(value); // h e l l o&#125;// arguments对象function add() &#123; for(let value of arguments) &#123; console.log(value); &#125;&#125;add(1, 3, 4, 5); // 1 3 4 5// DOM NodeList对象let divs = document.querySelectorAll('div');for(let div of divs) &#123; div.classList.add('test'); // 为每一个div添加一个‘test’类&#125; 并不是所有类似数组的对象都具有iterator接口，例如下面例子中的likeArray具有length属性，而且键名是数字，对于这种特殊的对象，可以使用Array.from将其先转为数组，然后遍历。12345678910let likeArray = &#123;length: 4, 1: 'b', 3: 'd'&#125;;// 报错，因为对象没有iterator接口for(let value of likeArray) &#123; console.log(value);&#125;for(let value of Array.from(likeArray)) &#123; console.log(value); // undefined b undefined d&#125; JavaScript遍历方法的比较我们以数组为例，JavaScript提供了多种方法遍历数组，常见的有for、forEach、for...in以及for...of，下面我们来依次比较一下这几种方法的不同之处。for循环是我们比较熟悉的12345678910let arr = [1, 3, 5, 6, 7];for(let i=0; i&lt;arr.length; i++) &#123; if(i === 2) &#123; continue; &#125; if(i &gt; 3) &#123; break; &#125; console.log(arr[i]); // 1 3 6&#125; for循环的好处就是能够使用continue、break、return等命令，而短处就是写起来比较麻烦，所有数组内置了forEach方法。12345678let arr = [1, 3, 5];arr.forEach((value, key) =&gt; &#123; value += 2; console.log(key, value); // 0 3 // 1 5 // 2 7&#125;) forEach内部是一个回调函数，可以对每个成员执行某种操作，但是无法中途跳出循环，continue、break命令无法生效。再来看for...in，for...in只能遍历数组的键名，而且它还有几个弊端。1234567891011let arr = [1, 3];for(let key in arr) &#123; console.log(key); // 0 1 console.log(typeof key); // string string console.log(arr[key]); // 1 3&#125;arr.name = '张三'; // 添加一个非数字键for(let key in arr) &#123; console.log(key); // 0 1 name console.log(arr[key]); // 1 3 张三&#125; 从上面的代码中我们可以看出for...in的几个弊端：1、数组的键名是数字，但是for...in循环是一字符串作为键名’0’、’1’、’2’等2、for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键3、某些情况下，for...in会以任意顺序遍历键名总而言之，不要使用for...in遍历数组，它只适合用来遍历对象。for...of相对于上面的几种遍历方法有以下优点1、和for...in一样的简洁语法，但是没有for...in的那些缺点2、不同于forEach方法，for...of中可以使用continue、break命令3、提供了遍历所有数据结构的统一接口12345678910111213141516let arr = [1, 2, 3, 4, 5, 6, 7, 8];for(let value of arr) &#123; if(value % 2) &#123; continue; &#125; if(value === 6) &#123; break; &#125; console.log(value); // 2 4&#125;arr.name = 9; // 添加一个非数字键名for(let key of arr.keys()) &#123; console.log(key); // 0 1 2 3 4 5 6 7&#125; 从上面的代码可以看出，for...of循环中可以使用continue和break循环控制命令，而且不会遍历非数字键名。 参考链接ECMAScript 6 入门（阮一峰）：Iterator和for…of循环]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习笔记（三）：Set和Map数据结构]]></title>
      <url>%2F2017%2F02%2F19%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ASet%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[Set的初始化 ES6提供了新的数据结构Set，它类似于数组，但是成员的值是唯一的，没有重复的值。 Set是一个构造函数，用来生成Set数据结构。123456let set = new Set();let arr = [1, 3, 4, 4, 5, 3, 2];arr.map(x =&gt; set.add(x));for(let value of set) &#123; console.log(set); // 1 3 4 5 2&#125; 上面的代码中Set通过实例的add方法来添加成员，结果表明Set不会添加重复的值。除了使用add方法之外，Set还可以接受一个数组（或类似数组的对象）作为参数来初始化。12345let set1 = new Set([1, 3, 3, 5, 4, 4]);let arr = [...set1]; // [1, 3, 5, 4]let divs = document.querySelectorAll('div');let set2 = new Set(divs);set2.size; // 10 去除数组重复成员的方法12let arr = [1, 3, 3, 5, 4, 4];arr = [...new Set(arr)]; // [1, 3, 5, 4] Set实例的属性和方法(1）Set实例的属性： 属性名 说明 Set.prototype.constructor 构造函数，默认就是Set函数 Set.prototype.size 返回Set实例的成员总数 (2) Set实例的方法：1、操作方法 方法名 说明 add(value) 添加一个值，返回Set结构本身 delete(value) 删除某个值，返回一个布尔值，表示删除是否成功 has(value) 判断某个值是不是Set的成员，返回一个布尔值 clear() 清除所有成员，没有返回值 操作方法使用示例1234567let set = new Set();set.add(1).add(2);set.has(1); // trueset.delete(1); // trueset.has(1); // falseset.clear();set.size; // 0 2、遍历方法 方法名 说明 keys() 返回键名的遍历器 values() 返回键值的遍历器 entries() 返回键值对的遍历器 forEach(value, key) 使用回调函数遍历，参数顺序为值，键 遍历方法使用示例123456789101112131415161718192021let set = new Set(['orange', 'apple', 'pear']);// 使用keys遍历键名for(let key of set.keys()) &#123; console.log(key); // orange apple pear&#125;// 使用values遍历键值for(let value of set.values()) &#123; console.log(value); // orange apple pear&#125;// 使用entries遍历键值对for(let item of set.entries()) &#123; console.log(item); // ["orange", "orange"] ["apple", "apple"] ["pear", "pear"]&#125;// 或者for(let [key, value] of set.entries()) &#123; console.log(key, value); // orange orange apple apple pear pear&#125;// 使用forEach遍历set.forEach((value, key) =&gt; &#123; console.log(key + ': ' + value); // orange: orange apple: apple pear: pear&#125;); 通过上面代码中entires方法遍历的返回值可以看出，Set结构的键名和键值是相同的，所以对于Set结构来说keys和values方法遍历是没有区别的。Set结构的实例默认可遍历，它调用的默认遍历函数就是values方法。1Set.prototype[Symbol.iterator] === Set.prototype.values; // true 这意味着，可以省略values方法，直接使用for...of遍历Set结构。1234let set = new Set(['orange', 'apple', 'pear']);for(let value of set) &#123; console.log(value); // orange apple pear&#125; Map的初始化 ES6新增了Map数据结构，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。传统的Object结构提供了“字符串-值”的对应，而Map结构提供了“值-值”的对应，功能更加完善。 Map是一个构造函数，用来生成Map数据结构。1234567let map = new Map();map.set(1, 1000); // 使用number当“键”map.set('auth', '张三'); // 使用string当“键”map.set(undefined, 'name'); // 使用undefined当“键”map.set(&#123;'sex': '男'&#125;, 1000); // 使用object当“键”map.set(null, 1000); // 使用null当“键”console.log(map); // &#123;1 =&gt; 1000, "auth" =&gt; "张三", undefined =&gt; "name", Object &#123;sex: "男"&#125; =&gt; 1, null =&gt; 1000&#125; 上面的代码中，使用set(key, value)方法为Map结构添加成员，而且这里的“键”可以是任何类型的值。除了set方法之外，Map还可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组。1234567let arr = [['name', '张三'], ['age', 30], ['sex'], [10, 20, 30]];let map = new Map(arr);map.get('name'); // '张三'map.get('age'); // 30map.get('sex'); // undefinedmap.get(10); // 20console.log(map); // &#123;"name" =&gt; "张三", "age" =&gt; 30, "sex" =&gt; undefined, 10 =&gt; 20&#125; Map接受数组作为参数，实际是执行的下面的操作。12345let arr = [['name', '张三'], ['age', 30]];let map = new Map();arr.forEach(([key, value]) =&gt; &#123; map.set(key, value);&#125;); 如果对一个键多次赋值，后面的值会覆盖前面的值。123let map = new Map();map.set('name', '张三').set('name', '李四');map.get('name'); // '李四' 如果读取一个不存在的键，将返回undefined。12let map = new Map();map.get('name'); // undefined 注意：只有对同一个对象的引用，Map结构才将其视为同一个键，这一点要非常小心。12345let map = new Map();map.set(&#123;'a': 1&#125;, 100);map.get(&#123;'a': 1&#125;); // undefinedmap.set([1], 200);map.get([1]); // undefined 上面的代码中，set和get中的键名是一样，但是实际上是两个值，因为内存地址是不一样的，所以get方法无法读取该键，返回undefined。要解决这种问题可以把键名是数组或对象的键用变量代替。1234567891011let map = new Map();let a = [1];let b = [1]let o = &#123;'a': 1&#125;;map.set(a, 100);map.get(a); // 100map.set(b, 200);map.get(b); // 200map.set(o, 300);map.get(o); // 300console.log(map); // &#123;[1] =&gt; 100, [1] =&gt; 200, Object &#123;a: 1&#125; =&gt; 200&#125; Map实例的属性和方法(1）Map实例的属性： 属性名 说明 Map.prototype.constructor 构造函数，默认就是Map函数 Map.prototype.size 返回Map实例的成员总数 （2）Map实例的方法：1、操作方法 方法名 说明 set(key, value) 设置key所对应的键值，返回Map结构本身 get(key) 读取key对应的键值，如果找不到key，返回undefined delete(key) 删除key对应的键和值，返回一个布尔值，表示删除是否成功 has(key) 判断某个键是不是Map的成员，返回一个布尔值 clear() 清除所有成员，没有返回值 操作方法使用示例1234567let map = new Map();map.set('a', 100).set('b', 200);map.get('a'); // 100map.delete('a'); // truemap.has('a'); // falsemap.clear();map.size; // 0 2、遍历方法 方法名 说明 keys() 返回键名的遍历器 values() 返回键值的遍历器 entries() 返回键值对的遍历器 forEach(value, key) 使用回调函数遍历，参数顺序为值，键 便利方法使用示例123456789101112131415161718192021let map = new Map([['name', '张三'], ['age', 30], ['addr', '深圳'], ['sex']]);// 使用keys遍历键名for(let key of map.keys()) &#123; console.log(key); // name age addr sex&#125;// 使用values遍历键值for(let value of map.values()) &#123; console.log(value); // 张三 30 深圳 undefined&#125;// 使用entries遍历键值对for(let item of map.entries()) &#123; console.log(item); // ["name", "张三"] ["age", 30] ["addr", "深圳"] ["sex", undefined]&#125;// 或者for(let [key, value] of map.entries()) &#123; console.log(key, value); // name 张三 age 30 addr 深圳 sex undefined&#125; Map结构的实例默认可遍历，它调用的默认遍历函数就是entries方法。1Map.prototype[Symbol.iterator] === Map.prototype.entries; // true 这意味着，可以省略entries方法，直接使用for...of遍历Map结构。1234let map = new Map([['name', '张三'], ['age', 30], ['addr', '深圳'], ['sex']]);for(let [key, value] of map) &#123; console.log(key, value); // name 张三 age 30 addr 深圳 sex undefined&#125; Map的forEach方法和数组的类似，可以对每个成员执行某种操作。1234let map = new Map([['a', 100], ['b', 200]]);map.forEach((value, key) =&gt; &#123; console.log(key, value*2); // a 200 b 400&#125;) 参考链接ECMAScript 6 入门（阮一峰）：Set和Map数据结构]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习笔记（二）：变量的解构赋值]]></title>
      <url>%2F2017%2F02%2F18%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[数组的解构赋值在ES6中允许按照一定的模式，从数组或对象中提取值，对变量进行赋值，这种方式称为解构（Destructuring）。在ES5中，我们是这样为变量赋值的123var a = 1;var b = 2;var c = 3; 而在ES6中，我们可以这样为变量赋值1let [a, b, c] = [1, 2, 3]; 从数组中提取值，按照对应的位置，为变量进行赋值。 本质上，这种方式属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值，同时也可以嵌套。12345let [a, [b, c], d] = [1, [2, 3], 4]; // a=1 b=2 c=3 d=4let [a, , c] = [1, 2, 3]; // a=1 c=3let [a, b, c] = [1, 2]; // a=1 b=2 c=undefinedlet [a, ...b] = [1, 2, 3, 4, 5]; // a=1 b=[2, 3, 4, 5]let [a, b, ...c] = [1]; // a=1 b=undefined c=[] 如果解构不成功，变量的值就为undefined，如果等号右边不是数组（严格说是不可遍历的解构），就会报错。1234567// 以下情况都会报错let [a] = 1;let [a] = false;let [a] = undefined;let [a] = null;let [a] = NaN;let [a] = &#123;&#125;; 默认值 解构赋值允许指定默认值1234let [a=2] = []; // a=2let [a, b=2] = [1]; // a=1 b=2let [a, b=2] = [1, undefined]; // a=1 b=2let [a, b=2] = [1, null]; // a=1 b=null (null不严格等于undefined，所以b的默认值2不生效) 注意，ES6中使用严格相等运算符（===），判断一个位置是不是有值，如果一个数组成员不是严格等于undefined，默认值就不会生效，例如上面的null不严格等于undefined，默认值就不会生效。 对象的解构赋值解构赋值不仅可以用于数组，也可以用于对象，这个时候有两种情况： 变量与属性同名123let &#123; name, age &#125; = &#123; name: '张三', age: 20 &#125;; // name='张三' age=20let &#123; age, name &#125; = &#123; name: '李四', age: 30 &#125;; // name='李四' age=30let &#123; name, sex &#125; = &#123; name: '张三' &#125;; // name='张三' sex=undefined 变量与属性不同名如果变量名与属性名不一样，必须写成下面这样12345678let &#123; name: n, age: a &#125; = &#123; name: '张三', age: 20&#125;; // n='张三' a=20let &#123; age: a, name: n &#125; = &#123; name: '张三', age: 20&#125;; // n='张三' a=20let &#123; name: n, sex: s &#125; = &#123; name: '张三' &#125;; // n='张三' s=undefined// 同样也可以嵌套let &#123; person: &#123;name, result&#125;&#125; = &#123; person: &#123; name: '张三', result: [90, 95]&#125;&#125;; // name='张三' result=[90, 95] 这其实说明，对象的解构赋值是下面形式的简写1let &#123; name: name, age: age &#125; = &#123; name: '张三', age: 20 &#125;; // name='张三' age=20 也就是说，对象的解构赋值的内部机制，是先找到同名的属性，然后再赋值给对应的变量。真正被赋值的是后者，而不是前者。123let &#123; name: n&#125; = &#123; name: '张三' &#125;;console.log(n); // 张三console.log(name); // ReferenceError: name is not defined 上面代码中，真正被赋值的是变量n而不是模式name。 默认值 对象的解构赋值也可以指定默认值，默认值生效的条件是属性的值严格等于undefined。12345let &#123; name='张三' &#125; = &#123;&#125;; // name='张三'let &#123; name, age=30&#125; = &#123; name: '张三' &#125;; // name='张三' age=30let &#123; name: n='张三' &#125; = &#123;&#125;; // n='张三'let &#123; name: n='张三' &#125; = &#123; name: undefined &#125;; // n='张三'let &#123; name: n='张三' &#125; = &#123; name: null &#125;; // n=null 字符串的解构赋值字符串也可以解构赋值，此时，字符串被转换成了一个类似数组的对象。1let [a, b, c, d, e] = 'hello'; // a='h' b='e' c='l' d='l' e='o' 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。1let &#123; length: len &#125; = 'hello'; // len=5 函数参数的解构赋值函数的参数也可以使用解构赋值1234function add([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3 上面的代码中，函数add的参数是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y，对于函数内部代码来说，他们能感受到的参数就是x和y。 函数的参数也可以使用默认值12345678function add(&#123;x=0, y=0&#125; = &#123;&#125;) &#123; return [x, y];&#125;add(&#123;x: 3, y: 4&#125;); // [3, 4]add(&#123;x: 3, y: undefined&#125;); // [3, 0]add(&#123;x: 3&#125;); // [3, 0]add(&#123;&#125;); // [0, 0]add(); // [0, 0] 因为没有传参，使用的默认值&#123;&#125; 上面代码中，函数add的参数是一个对象，x和y通过这个对象解构赋值，如果解构失败，x和y使用默认值。 注意，下面的写法会得到不一样的结果。1234567function add(&#123;x, y&#125; = &#123;x: 0, y: 0&#125;) &#123; return [x, y];&#125;add(&#123;x: 3, y: 4&#125;); // [3, 4]add(&#123;x: 3&#125;); // [3, undefined]add(&#123;&#125;); // [undefined, undefined]add(); // [0, 0] 因为没有传参，使用默认值&#123;x: 0, y: 0&#125; 上面的代码是为函数add的参数指定默认值，而不是为变量x和y指定默认值，所以会得到和上面不同的结果。 用途交换变量的值1234let a = 1, b = 2;[a, b] = [b, a];console.log(a); // 2console.log(b); // 1 从函数返回多个值函数只能返回一个值，如果要返回多个值，就需要放到数组或对象中返回，有了结构赋值，取出这些返回值就简单多了。123456789function func1() &#123; return [1, 2, 3];&#125;let [a, b, c] = func1(); // a=1 b=2 c=3function func2() &#123; return &#123;name: '张三', age: 20&#125;;&#125;let &#123;name, age&#125; = func2(); // name='张三' age=20 函数参数的定义解构赋值可以方便的将一组参数与变量名对应起来。1234567891011// 参数是有序的值function func1([x, y, z]) &#123; return [x, y, z];&#125;func1([1, 2, 3]); // [1, 2, 3]// 参数是无序的值function func2(&#123;x, y, z&#125;) &#123; return &#123;x, y, z&#125;;&#125;func2(&#123;x: 1, z: 3, y: 2&#125;); // &#123;x: 1, y: 2, z: 3&#125; 提取JSON数据解构赋值提取JSON中的数据非常有用。1234567var data = &#123; name: '张三', age: 90, sex: '男', result: [80, 90]&#125;;let &#123; name, age, result &#125; = data; 函数参数的默认值指定参数的默认值，就避免了在函数体内再写var foo = config.foo || &#39;default config&#39;;这样的判断语句。123456789jQuery.ajax = function(url, &#123; async: true, beforeSend: function() &#123;&#125;, cache: true, complete: function() &#123;&#125; // ... 更多配置&#125;) &#123; // ...&#125; 遍历Map结构任何部署了Iterator接口的对象都可以使用for...of循环遍历，Map结构原生支持Iterator接口，配合解构赋值，获取键名和键值就非常方便。12345678var map = new Map();map.set('name', '张三');map.set('age', 20);for(let [key, value] of map) &#123; console.log(key + ' is ' + value);&#125;// name is 张三// age is 20 输入模块的指定方法加载模块时，往往需要指定加载模块的哪些方法，使用解构赋值使得输入非常清晰。1import &#123; func1, func2, func3 &#125; from 'module'; 参考链接：ECMAScript 6 入门（阮一峰）：变量的解构赋值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习笔记（一）：let和const命令]]></title>
      <url>%2F2017%2F02%2F18%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Alet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ES6新增了let和const两个命令来声明变量，这两个新的命令和ES5中的var命令有很多不同之处，而且使用let和const会让代码看起来更严谨。 块级作用域在ES5的时候，只有全局作用域和函数作用域，ES6新增了块级作用域的概念，看下面的代码123456&#123; var a = 1; let b = 1;&#125;console.log(a); // 1console.log(b); // ReferenceError: b is not defined 在上面的代码块之中，分别用var和let声明了变量a和b，然后我们在代码块之外访问变量a和b,结果用var声明的变量a能够访问到，而用let声明的变量b报错了。这表明，用let声明的变量只在它所在的代码块内有效。for循环中的计数器就非常适合用let来声明，用let声明的计数器i的作用域仅仅在循环体中，外部是没法访问到的，而用var声明的计数器j的作用域却是全局的，在任何地方都能访问，而这并不是我们想要的结果。 不存在变量提升（必须先声明后使用）用let声明的变量不会像var那样发生变量提升的现象，如果使用之前没有声明，就会报错。1234console.log(a); // undefinedconsole.log(b); // ReferenceError: b is not definedvar a = 1;let b = 1; 上面的代码中，a是用var命令声明的，会发生变量提升(相当于自动在代码的顶部添加了var a;这一句)，即脚本运行的时候a其实就已经存在了，只不过没有赋值，所以输出undefined。而let声明的变量不会提升，所以在使用的时候如果发现还没有声明，就会报错。这样也能够让我们在写代码的时候更规范，变量必须先声明后使用。 暂时性死区只要块级作用域中存在let命令，它所声明的变量就会绑定（binding）这一区域，不再受外部的影响。12345let tmp = 1;if(true) &#123; tmp = 2; // ReferenceError: tmp is not defined let tmp; // 这个局部变量tmp会绑定所在的块级作用域，在此之前不能访问变量tmp&#125; 上面代码中，存在全局变量tmp，但是在块级作用域内let又声明了一个局部变量tmp，导致后者绑定了这一区域，所以在let声明tmp之前，对tmp进行赋值会报错 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量从一开始就形成了一个封闭作用域，凡是在声明之前就使用这些变量，就会报错。总之，在代码块内使用let或const声明变量之前，这些变量都是不可用的。在语法上，这称为暂时性死区。 不允许重复声明同一变量（在同一个块级作用域内）let和const不允许在同一个作用域内重复声明同一变量。1234567891011function func() &#123; let a = 1; var a = 2; // 报错 const b = 1; const b = 2; // 报错&#125;function func() &#123; let a = 1; let a = 2; // 报错&#125; 因此，不能在函数内部重新声明参数123456789function func(a) &#123; let a = 5; // 报错&#125;function func(a) &#123; &#123; let a = 5; // 不报错，不在同一作用域内 &#125;&#125; const声明的常量不允许修改ES6新增了const命令，用来声明一个常量，既然是常量，就意味着一旦声明之后，变量的值就不能修改123const PI = 3.1415;console.log(PI); // 3.1415PI = 3; // 报错，常量的值不能修改 既然const声明的常量不允许修改值，那就意味着，一旦声明就必须立即初始化，不能留到后面再赋值12const PI; // 报错，必须赋值const MAX = 5; 参考链接：ECMAScript 6 入门（阮一峰）：let和const命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js常用代码]]></title>
      <url>%2F2017%2F01%2F20%2Fjs%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[返回指定范围的随机数(m-n之间)的公式123456function random(m, n) &#123; return Math.random() * (n-m) + m;&#125;// examplerandom(3, 5); // 4.680004527528821 rem布局（动态设置html根节点font-size大小）12345678910111213141516171819202122(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; function recalc() &#123; var clientWidth = docEl.clientWidth&gt;540 ? 540 : docEl.clientWidth; // 控制最大宽度为540px if (!clientWidth) return; //此处的100为页面html设置的字体大小值（为方便计算一般用100px） //此处的320为视觉稿宽度的一半 //根据设备可视区的宽度以及设备像素比动态改变fontSize值 docEl.style.fontSize = 100 * (clientWidth / 320) + 'px'; &#125;; recalc(); if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); if (doc.readyState === 'complete') &#123; recalc(); &#125; else &#123; doc.addEventListener('DOMContentLoaded', recalc, false); &#125;&#125;)(document, window); 字符串超过指定长度的部分用’…’代替1234567891011121314151617181920212223function cutstr(str, len) &#123; var temp, icount = 0, patrn = /[^\x00-\xff]/, strre = ""; for (var i = 0; i &lt; str.length; i++) &#123; if (icount &lt; len - 1) &#123; temp = str.substr(i, 1); if (patrn.exec(temp) == null) &#123; icount = icount + 1; &#125; else &#123; icount = icount + 2; &#125; strre += temp; &#125; else &#123; break; &#125; &#125; return strre + "...";&#125;// examplecutstr('abcdefghijk', 3); // "ab..." 替换全部123456String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, "gm"), s2);&#125;// example'abbcdbbbeeff'.replaceAll('bb', '**'); // "a**cd**beeff" 清除左右空格1234567String.prototype.trim = function() &#123; var reExtraSpace = /^\s*(.*?)\s+$/; return this.replace(reExtraSpace, "$1");&#125;// example' abcd ef '.trim(); // "abcd ef" 清除左空格/右空格1234567891011function ltrim(s) &#123; return s.replace(/^(\s*| *)/, "");&#125;function rtrim(s) &#123; return s.replace(/(\s*| *)$/, "");&#125;// exampleltrim(' abcd ef '); // "abcd ef "rtrim(' abcd ef '); // " abcd ef" 判断是否以某个字符串开头1234567String.prototype.startWith = function(s) &#123; return this.indexOf(s) === 0;&#125;// example'abcdef'.startWith('ab'); // true'abcdef'.startWith('bc'); // false 判断是否以某个字符串结束12345678String.prototype.endWith = function(s) &#123; var d = this.length - s.length; return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d);&#125;// example'abcdef'.endWith('ef'); // true'abcdef'.endWith('de'); // false 转义html标签1234567891011121314151617function encodeHtml(s) &#123; var REGX_HTML_ENCODE = /"|&amp;|'|&lt;|&gt;|[\x00-\x20]|[\x7F-\xFF]|[\u0100-\u2700]/g; var s = (s != undefined) ? s : this.toString(); return (typeof s != "string") ? s : s.replace(REGX_HTML_ENCODE, function($0) &#123; var c = $0.charCodeAt(0), r = ["&amp;#"]; c = (c == 0x20) ? 0xA0 : c; r.push(c); r.push(";"); return r.join(""); &#125;);&#125;// exampleencodeHtml('&lt;a&gt;哈哈哈哈哈哈&lt;/a&gt;'); // "&amp;#60;a&amp;#62;哈哈哈哈哈哈&amp;#60;/a&amp;#62;" 反转义html12345678910111213141516171819202122232425262728293031function decodeHtml(s) &#123; var HTML_DECODE = &#123; "&lt;": "&lt;", "&gt;": "&gt;", "&amp;": "&amp;", " ": " ", '"': '\"', "©": "" // Add more &#125;; var REGX_HTML_DECODE = /&amp;\w+;|&amp;#(\d+);/g; var s = (s != undefined) ? s : this.toString(); return (typeof s != "string") ? s : s.replace(REGX_HTML_DECODE, function($0, $1) &#123; var c = HTML_DECODE[$0]; if (c == undefined) &#123; // Maybe is Entity Number if (!isNaN($1)) &#123; c = String.fromCharCode(($1 == 160) ? 32 : $1); &#125; else &#123; c = $0; &#125; &#125; return c; &#125;);&#125;// exampledecodeHtml("&amp;#60;a&amp;#62;哈哈哈哈哈哈&amp;#60;/a&amp;#62;"); // "&lt;a&gt;哈哈哈哈哈哈&lt;/a&gt;" 时间日期格式转换12345678910111213141516171819202122232425Date.prototype.Format = function(formatStr) &#123; var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : '0' + (this.getYear() % 100)); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/M/g, (this.getMonth() + 1)); str = str.replace(/w|W/g, Week[this.getDay()]); str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : '0' + this.getDate()); str = str.replace(/d|D/g, this.getDate()); str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : '0' + this.getHours()); str = str.replace(/h|H/g, this.getHours()); str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : '0' + this.getMinutes()); str = str.replace(/m/g, this.getMinutes()); str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : '0' + this.getSeconds()); str = str.replace(/s|S/g, this.getSeconds()); return str&#125;// examplenew Date().Format('YYYY/MM/DD'); // "2017/01/22"new Date().Format('yyyy-MM-dd'); // "2017-01-22"new Date().Format('hh:mm:ss'); // "10:31:19"new Date().Format('yyyy-MM-dd hh:mm:ss'); // "2017-01-22 10:28:32"new Date().Format('yyyy-MM-dd 星期w hh:mm:ss'); // "2017-01-22 星期日 10:29:29" 获得当前页面URL中GET参数值12345678910111213function getQueryString(name) &#123; var reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null;&#125;// example url = 'www.baidu.com?a=123&amp;b=&amp;c=345'getQueryString('a'); // "123"getQueryString('b'); // ""getQueryString('d'); // null 金额大写转换函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function transform(tranvalue) &#123; try &#123; var i = 1; var dw2 = new Array("", "万", "亿"); //大单位 var dw1 = new Array("拾", "佰", "仟"); //小单位 var dw = new Array("零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"); //整数部分用 //以下是小写转换成大写显示在合计大写的文本框中 //分离整数与小数 var source = splits(tranvalue); var num = source[0]; var dig = source[1]; //转换整数部分 var k1 = 0; //计小单位 var k2 = 0; //计大单位 var sum = 0; var str = ""; var len = source[0].length; //整数的长度 for (i = 1; i &lt;= len; i++) &#123; var n = source[0].charAt(len - i); //取得某个位数上的数字 var bn = 0; if (len - i - 1 &gt;= 0) &#123; bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字 &#125; sum = sum + Number(n); if (sum != 0) &#123; str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面 if (n == '0') sum = 0; &#125; if (len - i - 1 &gt;= 0) &#123; //在数字范围内 if (k1 != 3) &#123; //加小单位 if (bn != 0) &#123; str = dw1[k1].concat(str); &#125; k1++; &#125; else &#123; //不加小单位，加大单位 k1 = 0; var temp = str.charAt(0); if (temp == "万" || temp == "亿") //若大单位前没有数字则舍去大单位 str = str.substr(1, str.length - 1); str = dw2[k2].concat(str); sum = 0; &#125; &#125; if (k1 == 3) &#123; //小单位到千则大单位进一 k2++; &#125; &#125; //转换小数部分 var strdig = ""; if (dig != "") &#123; var n = dig.charAt(0); if (n != 0) &#123; strdig += dw[Number(n)] + "角"; //加数字 &#125; var n = dig.charAt(1); if (n != 0) &#123; strdig += dw[Number(n)] + "分"; //加数字 &#125; &#125; str += "元" + strdig; &#125; catch (e) &#123; return "0元"; &#125; return str;&#125;//拆分整数与小数function splits(tranvalue) &#123; var value = new Array('', ''); temp = tranvalue.toFixed(2).split("."); for (var i = 0; i &lt; temp.length; i++) &#123; value = temp; &#125; return value;&#125;// exampletransform(3333); // "叁仟叁佰叁拾叁元"transform(3333.3455); // "叁仟叁佰叁拾叁元叁角伍分"transform(333456762.32); // "叁亿叁仟叁佰肆拾伍万陆仟柒佰陆拾贰元叁角贰分"transform(32323423423.3455); // transform(32323423423.3455); 判断一个对象是否为空对象12345678910function isEmptyObject(obj) &#123; for(var i in obj) &#123; return false; &#125; return true;&#125;// exampleisEmptyObject(&#123;&#125;); // trueisEmptyObject(&#123;a: 3&#125;); // false 获取数组中的最小最大值1234567891011function smallest(array)&#123; return Math.min.apply(Math, array);&#125;function largest(array)&#123; return Math.max.apply(Math, array);&#125;// examplesmallest([1, 2, 3, 0, 0, 1]); // 0largest([1, 2, 3, 0, 0, 1]); // 3 判断两个小数是否相等12345678910111213141516//因为javascript数字通常被输入为十进制的浮点数，但内部却被表示为二进制，所以计算结果会有偏差：// 首先看下面的几个例子0.1 + 0.2; // 0.300000000000000041.2 - 0.1; // 1.09999999999999990.1 + 0.2 === 0.3; // false//所以我们不应该直接比较非整数，而是取其上限，把误差计算进去//这样一个上限称为 machine epsilon，双精度的标准epsilon值是2^-53const EPSILON = Math.pow(2, -53); //1.1102230246251565e-16function epsEqu(x, y) &#123; return Math.abs(x - y) &lt; EPSILON;&#125;// exampleepsEqu(0.1+0.2, 0.3); // true 上传图片预览功能12&lt;input type="file" name="file" onchange="showPreview(this)" /&gt;&lt;img id="portrait" src="" width="70" height="75"&gt; 12345678910function showPreview(source) &#123; var file = source.files[0]; if(window.FileReader) &#123; var fr = new FileReader(); fr.onloadend = function(e) &#123; document.getElementById("portrait").src = e.target.result; &#125;; fr.readAsDataURL(file); &#125;&#125; cookie操作1234567891011121314151617181920212223242526// 设置cookiefunction setCookie(c_name, value, expiredays) &#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie = c_name + "=" +escape(value) + ((expiredays==null) ? "" : ";expires=" + exdate.toGMTString());&#125;// 获取cookiefunction getCookie(c_name) &#123; if (document.cookie.length&gt;0) &#123; var c_start = document.cookie.indexOf(c_name + "="); if (c_start != -1) &#123; c_start = c_start + c_name.length + 1; var c_end = document.cookie.indexOf(";",c_start); if (c_end == -1) c_end = document.cookie.length; return unescape(document.cookie.substring(c_start,c_end)); &#125; &#125; return "";&#125;// examplesetCookie('name', 'zhangsan', 7);getCookie('name'); // "zhangsan"setCookie('name', 'zhangsan', -1);getCookie('name'); // "" 参考链接：原生JavaScript技巧大收集100js常用代码不定期更新JavaScript技巧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime text 常用插件]]></title>
      <url>%2F2016%2F12%2F13%2Fsublime-text-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[sublime被誉为前端开发神器，虽然小巧但是性能强悍，而且可以高度自定义，包括安装各种功能强大的插件、主题，能够极大的提高编码效率。 安装sublime textsublime text官网下载地址：https://www.sublimetext.com/download 安装插件Package Control在安装插件之前需要首先安装Package Control（sublime的包管理器），能够帮助我们实现插件的安装、删除、更新等操作 安装package Control步骤 按下Ctrl + ` 打开控制台 在控制台中粘贴下面的代码并运行（只适用于sublime text 3） 1import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 运行成功之后，重启sublime text，按下Cmd + Shift + P就可以调出管理面板，在里面输入package control install package，选择第一项就可以安装插件了 EmmetEmmet能够帮助我们快速写html代码，比如我们要实现如下的代码结构，只需要这样写ul.list&gt;li.item{列表项$}*4，然后按下Tab键即可，写起来非常的方便，具体的使用方法可以参考：http://docs.emmet.io/ 123456&lt;ul class="list"&gt; &lt;li class="item"&gt;列表项1&lt;/li&gt; &lt;li class="item"&gt;列表项2&lt;/li&gt; &lt;li class="item"&gt;列表项3&lt;/li&gt; &lt;li class="item"&gt;列表项4&lt;/li&gt;&lt;/ul&gt; SublimeTmplSublimeTmpl是一款快速生成文件模板的插件，按下快捷键就可以帮我们生成对应的文件 123ctrl+alt+h 生成html文件ctrl+alt+j 生成javascript文件ctrl+alt+c 生成css文件 HTML-CSS-JS PrettifyHTML-CSS-JS Prettify是一款代码格式化、美化的工具（只适用于html、css、js文件），安装完成之后，只需按下快捷键Cmd+Shift+H（或者点击右键选择HTML-CSS-JS Prettify），就可以让代码结构变得非常规范，看起来赏心悦目 Auto​File​NameAuto​File​Name能够帮助我们自动完成文件名，例如当我们要引入images目录中的某一张图片时，它会显示当前目录中的所有图片名称供我们选择 Bracket​HighlighterBracket​Highlighter能够高亮显示配对的括号、大括号、html标签，当代码很长时，能够方便的查看代码的结构，效果如下图所，在行号那里会高亮显示配对的大括号，非常明显 Doc​BlockrDoc​Blockr能够帮助我们快速生成注释，这里我们定义了一个函数test有三个参数，现在我们想给这个函数加上注释，只需要在函数的上面一行输入/**然后按下Enter键，就会自动帮我们生成规范的注释 GitGit是一款优秀的版本管理工具，几乎每个程序员都需要用到，sublime text的Git插件可以高亮显示哪些代码被修改过，但是还没有提交，便于我们清楚的知道都改动了哪些地方 Side​Bar​EnhancementsSide​Bar​Enhancements是一款目录结构右键增强插件，当我们右键点击左侧SideBar中的文件或文件夹时，可以提供更多的操作，例如文件删除、重命名，在当前目录中执行查找、替换等操作 Material ThemeMaterial Theme是一款非常受欢迎的sublime text主题，我自己目前使用的就是这一款，安装完成之后选择Sublime Text &gt; Preferences &gt; Setting打开设置页面，在里面添加这两行代码就可使主题生效 12"color_scheme": "Packages/Material Theme/schemes/Material-Theme.tmTheme","theme": "Material-Theme.sublime-theme", 最后附上自己的Sublime Text &gt; Preferences &gt; Setting文件常用设置项 1234567891011121314&#123; "color_scheme": "Packages/Material Theme/schemes/Material-Theme.tmTheme", "theme": "Material-Theme.sublime-theme", "draw_white_space": "all", "ensure_newline_at_eof_on_save": true, "font_size": 16, "highlight_line": true, "ignored_packages": [ "Vintage" ], "line_padding_bottom": 1, "line_padding_top": 1, "tab_size": 2, "translate_tabs_to_spaces": true, "trim_tralling_white_space_on_save": true&#125; 参考链接：如何优雅地使用Sublime TextSublime Text 全程指南Material Theme 主题Sublime Text 最受欢迎的插件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F11%2Fhello-world%2F</url>
      <content type="text"><![CDATA[折腾了两个晚上，终于把博客搭好了 之前自己通过github也搭了一个小小的个人网站，希望能够记录一些东西 无奈管理起来太麻烦，也没有现有的轮子高大上，所以就把网站迁移到coding上去了，贴一下网址我的个人网站 废话不多说，接下来的时间就需要挑灯夜战开始写写写了…]]></content>
    </entry>

    
  
  
</search>
